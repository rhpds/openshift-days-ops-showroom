= OpenShift Virtualization

== Module Overview

**Duration:** 25 minutes +
**Audience:** Infrastructure Architects, IT Operations

Your organization has workloads running on VMs that can't be containerized yet. OpenShift Virtualization lets you run VMs alongside containers on the same platform — same tools, same networking, same monitoring. No separate hypervisor infrastructure needed.

== Learning Objectives

* Create and access a virtual machine
* See how VMs are just pods under the hood
* Expose a VM using the same networking as containers
* Live migrate a running VM between nodes
* Take snapshots for backup/rollback

== Prerequisites Check

OpenShift Virtualization should already be installed. Verify:

[source,bash,role="execute"]
----
oc get csv -n openshift-cnv | grep kubevirt
----

Expected output shows `Succeeded`:
----
kubevirt-hyperconverged-operator.v4.20.x   OpenShift Virtualization   4.20.x   Succeeded
----

== Create a VM

[source,bash,role="execute"]
----
oc new-project vm-demo
----

Deploy a RHEL 9 VM from a pre-cached boot image:

[source,bash,role="execute"]
----
cat <<EOF | oc apply -f -
apiVersion: kubevirt.io/v1
kind: VirtualMachine
metadata:
  name: rhel9-vm
  namespace: vm-demo
spec:
  runStrategy: Always
  dataVolumeTemplates:
  - metadata:
      name: rhel9-vm-disk
    spec:
      sourceRef:
        kind: DataSource
        name: rhel9
        namespace: openshift-virtualization-os-images
      storage:
        resources:
          requests:
            storage: 30Gi
  template:
    metadata:
      labels:
        kubevirt.io/vm: rhel9-vm
    spec:
      domain:
        cpu:
          cores: 1
        devices:
          disks:
          - name: rootdisk
            disk:
              bus: virtio
          - name: cloudinitdisk
            disk:
              bus: virtio
        resources:
          requests:
            memory: 2Gi
      volumes:
      - name: rootdisk
        dataVolume:
          name: rhel9-vm-disk
      - name: cloudinitdisk
        cloudInitNoCloud:
          userData: |
            #cloud-config
            user: cloud-user
            password: redhat
            chpasswd:
              expire: false
EOF
----

Wait for the VM to start (1-2 minutes):

[source,bash,role="execute"]
----
oc get vms -w
----

Press `Ctrl+C` when STATUS shows `Running`.

== Access the VM

=== Web Console

1. In the OpenShift console, select the **Fleet Virtualization** perspective from the top-left dropdown
2. Click on **rhel9-vm** in the VM list
3. Click **Open Web Console**
4. Login with: `cloud-user` / `redhat`

image::virt-rhel9-vm-console.png[rhel9-vm web console]

=== Serial Console (CLI)

[source,bash,role="execute"]
----
virtctl console rhel9-vm
----

Login with `cloud-user` / `redhat`. Press `Ctrl+]` to disconnect.

== It's Just a Pod

This is the key insight. Your VM runs inside a `virt-launcher` pod — managed by the same scheduler, same networking, same storage as containers:

[source,bash,role="execute"]
----
oc get pods -n vm-demo
----

You'll see:

----
NAME                          READY   STATUS    RESTARTS   AGE
virt-launcher-rhel9-vm-xxxxx   2/2     Running   0          3m
----

That's your VM. It's a pod. The same `oc` commands work:

[source,bash,role="execute"]
----
oc describe pod -l kubevirt.io/vm=rhel9-vm -n vm-demo | tail -10
----

== Unified Monitoring

Your VM's metrics appear in the same Prometheus dashboards as your containers. No separate monitoring stack needed.

In the Fleet Virtualization perspective, click **rhel9-vm** → **Metrics** tab to see:

* CPU usage over time
* Memory consumption
* Network I/O

Or query from CLI — the VM uses resources just like any pod:

[source,bash,role="execute"]
----
oc adm top pods -n vm-demo
----

== Expose the VM (Same Networking as Containers)

VMs get pod IPs on the same SDN as containers. You can create Services and Routes for VMs exactly like you do for container workloads:

[source,bash,role="execute"]
----
oc get vmi rhel9-vm -o jsonpath='{.status.interfaces[0].ipAddress}' && echo ""
----

Create a Service pointing to the VM:

[source,bash,role="execute"]
----
oc apply -f - <<EOF
apiVersion: v1
kind: Service
metadata:
  name: rhel9-vm-ssh
  namespace: vm-demo
spec:
  selector:
    kubevirt.io/vm: rhel9-vm
  ports:
  - port: 22
    targetPort: 22
EOF
----

[source,bash,role="execute"]
----
oc get svc rhel9-vm-ssh -n vm-demo
----

The VM is now reachable via the service — the same way you'd expose a container. Same label selectors, same service types, same networking model.

== Live Migration

Move a running VM to a different node with zero downtime. This is the killer feature for maintenance windows — drain a node without stopping VMs.

Check which node the VM is currently on:

[source,bash,role="execute"]
----
oc get vmi rhel9-vm -o jsonpath='{.status.nodeName}' && echo ""
----

Trigger a live migration:

[source,bash,role="execute"]
----
virtctl migrate rhel9-vm
----

Watch the migration:

[source,bash,role="execute"]
----
oc get vmim -w
----

Press `Ctrl+C` when the migration completes. Verify the VM moved to a different node:

[source,bash,role="execute"]
----
oc get vmi rhel9-vm -o jsonpath='{.status.nodeName}' && echo ""
----

The VM moved to a different node while still running. No downtime, no reconnection needed.

== Snapshots

Capture VM state before risky changes (patches, upgrades):

[source,bash,role="execute"]
----
cat <<EOF | oc apply -f -
apiVersion: snapshot.kubevirt.io/v1beta1
kind: VirtualMachineSnapshot
metadata:
  name: rhel9-vm-snap-1
  namespace: vm-demo
spec:
  source:
    apiGroup: kubevirt.io
    kind: VirtualMachine
    name: rhel9-vm
EOF
----

Check snapshot status:

[source,bash,role="execute"]
----
oc get vmsnapshot
----

To restore, stop the VM first then apply a `VirtualMachineRestore` CR pointing to the snapshot.

== Summary

| Feature | What it means for ops |
|---------|----------------------|
| **VMs are pods** | Same `oc` commands, same scheduler, same RBAC |
| **Same networking** | Services and Routes work for VMs and containers |
| **Same monitoring** | Prometheus dashboards show VM and container metrics together |
| **Live migration** | Drain nodes for maintenance without VM downtime |
| **Snapshots** | Point-in-time recovery before patches or upgrades |

**The value:** Run legacy VMs and modern containers side-by-side. One platform, one set of tools, gradual migration path. No separate hypervisor infrastructure to manage.
